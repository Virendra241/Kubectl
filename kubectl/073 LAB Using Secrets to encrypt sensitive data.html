<html>
                <head>
                <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
                <title>073 LAB Using Secrets to encrypt sensitive data</title>
                </head>
                <body>
                <div class="container">
                <div class="row">
                <div class="col-md-10 col-md-offset-1">
                    <p class="lead"><h4><strong>Secrets</strong></h4><p>Secrets are for storing sensitive data like <em>passwords and keychains</em>. We will see how db deployment uses username and password in form of a secret.</p><p>You would define two fields for db,</p><ul><li><p>username</p></li><li><p>password</p></li></ul><p>To create secrets for db you need to generate <em>base64</em> format as follows,</p><pre class="prettyprint linenums">echo "admin" | base64
echo "password" | base64
</pre><p>where <strong>admin</strong> and <strong>password</strong> are the actual values that you would want to inject into the pod environment.</p><p>If you do not have a unix host, you can make use of online base64 utility to generate these strings.</p><pre class="prettyprint linenums">http://www.utilities-online.info/base64
</pre><p><strong>Lets now add it to the secrets file,</strong></p><p>File: projects/instavote/dev/db-secrets.yaml</p><pre class="prettyprint linenums">apiVersion: v1
kind: Secret
metadata:
  name: db
  namespace: instavote
type: Opaque
data:
  POSTGRES_USER: YWRtaW4=
  POSTGRES_PASSWD: cGFzc3dvcmQ=
</pre><pre class="prettyprint linenums">kubectl apply -f db-secrets.yaml

kubectl get secrets

kubectl describe secret db
</pre><p><strong>Secrets can be referred to inside a container spec with following syntax</strong></p><pre class="prettyprint linenums">env:
  - name: VAR
    valueFrom:
      secretKeyRef:
        name: db
        key: SECRET_VAR
</pre><p>To consume these secrets, update the deployment for db</p><p>file: db-deploy.yaml</p><pre class="prettyprint linenums">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: db
  namespace: instavote
spec:
  replicas: 1
  selector:
    matchLabels:
      tier: back
      app: postgres
  minReadySeconds: 10
  template:
    metadata:
      labels:
        app: postgres
        role: db
        tier: back
    spec:
      containers:
      - image: postgres:9.4
        imagePullPolicy: Always
        name: db
        ports:
        - containerPort: 5432
          protocol: TCP
        # Secret definition
        env:
          - name: POSTGRES_USER
            valueFrom:
              secretKeyRef:
                name: db
                key: POSTGRES_USER
          - name: POSTGRES_PASSWD
            valueFrom:
              secretKeyRef:
                name: db
                key: POSTGRES_PASSWD
      restartPolicy: Always
</pre><p>To apply this,</p><pre class="prettyprint linenums">kubectl apply -f db-deploy.yaml

kubectl apply -f db-svc.yaml

kubectl get rs,deploy --show-labels
</pre><h4><strong>Note: Automatic Updation of deployments on ConfigMap Updates</strong></h4><p>Currently, updating configMap does not ensure a new rollout of a deployment. What this means is even after updading configMaps, pods will not immediately reflect the changes.</p><p>There is a feature request for this https://github.com/kubernetes/kubernetes/issues/22368</p><p>Currently, this can be done by using immutable configMaps.</p><ul><li><p>Create a configMaps and apply it with deployment.</p></li><li><p>To update, create a new configMaps and do not update the previous one. Treat it as immutable.</p></li><li><p>Update deployment spec to use the new version of the configMaps. This will ensure immediate update.</p></li></ul></p>
                </div>
                </div>
                </div>
                <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
                </body>
                </html>